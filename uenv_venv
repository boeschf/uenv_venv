#!/usr/bin/env python3
"""
uenv-venv: create a Python venv on top of an active uenv.

Features:
  - uses `uv venv` if available, else Python's built-in `venv`
  - refuses to run if the selected Python is NOT inside the active uenv
  - ignores uenv's PYTHONPATH when creating the venv
  - writes a .pth so the venv sees packages from the uenv's site-packages:
      <mount>/env/<uenv-name>/lib/pythonX.Y/site-packages

Reads env:
  UENV_VIEW="<mount>:<uenv-name>:<view-name>"

Usage:
  uenv_venv --venv ~/venvs/myvenv
Options:
  --python /path/to/python  (defaults to current interpreter)
  --force                   (remove existing venv directory first)
  --copies                  (prefer copies instead of symlinks)
"""

from __future__ import annotations
import argparse
import os
import re
import shutil
import subprocess
import sys
from pathlib import Path
import venv

def parse_uenv() -> tuple[Path, str, str]:
    uv = os.environ.get("UENV_VIEW", "")
    if uv:
        parts = uv.split(":", 3)
        if len(parts) == 3:
            mount, name, view = parts
            return Path(mount), name, view
    uml = os.environ.get("UENV_MOUNT_LIST", "")
    if uml:
        # take last "<squashfs>:<mount>" entry
        for token in reversed(re.split(r"[ ,]", uml.strip())):
            if token and ":" in token:
                mount = token.rsplit(":", 1)[-1]
                return Path(mount), "", ""
    sys.exit("ERROR: Could not detect uenv.")

def py_in_uenv(py: Path, mount: Path) -> bool:
    try:
        return Path(py).resolve().as_posix().startswith(Path(mount).resolve().as_posix() + "/")
    except Exception:
        return False

def discover_uenv_site_packages(mount: Path, view_name: str, py: Path) -> Path:
    """
    Prefer the uenv *view* site-packages by scanning the interpreter's sys.path
    for entries under: <mount>/env/<view_name>/lib/pythonX.Y/site-packages

    If not found, fall back to the deterministic path and verify it exists.
    """
    # Ask the chosen Python for version and sys.path
    code = r"""
import sys, json
pyver = f"{sys.version_info[0]}.{sys.version_info[1]}"
print(json.dumps({"ver": pyver, "path": sys.path}))
"""
    out = subprocess.check_output([str(py), "-c", code]).decode()
    data = __import__("json").loads(out)
    pyver = data["ver"]
    sys_path = [Path(p).resolve() for p in data["path"] if isinstance(p, str)]

    # Target prefix inside the view
    want_prefix = (mount / "env" / view_name / "lib" / f"python{pyver}" / "site-packages").resolve()

    # Prefer the first sys.path entry that is inside the view's site-packages
    for p in sys_path:
        try:
            if p.is_dir() and str(p).startswith(str(want_prefix)):
                return p
        except Exception:
            pass

    # Fallback: use the deterministic view path if it exists
    if want_prefix.is_dir():
        return want_prefix

    # As a last resort, error with a helpful message
    raise SystemExit(
        "ERROR: Could not locate the uenv view's site-packages.\n"
        f"  looked for: {want_prefix}\n"
        "Hint: ensure the uenv is active and exposes its view on sys.path, "
        "or pass --mount and --uenv-name and verify the directory exists."
    )

def venv_site_packages(venv_python: Path) -> Path:
    code = "import sysconfig;print(sysconfig.get_paths()['purelib'])"
    out = subprocess.check_output([str(venv_python), "-c", code]).decode().strip()
    return Path(out)

def create_with_uv(target: Path, py: Path, copies: bool, env: dict) -> None:
    uv = shutil.which("uv")
    if not uv:
        raise FileNotFoundError
    cmd = [uv, "venv", str(target), "--python", str(py)]
    if copies:
        cmd.append("--copies")
    subprocess.check_call(cmd, env=env)

def create_with_stdlib(target: Path, py: Path, copies: bool, env: dict) -> None:
    cmd = [str(py), "-m", "venv", str(target)]
    if copies:
        cmd.append("--copies")
    subprocess.check_call(cmd, env=env)

def main():
    ap = argparse.ArgumentParser(description="Create a venv layered on an active uenv.")
    ap.add_argument("--venv", required=True, type=Path, help="Target venv directory")
    ap.add_argument("--python", default=sys.executable, type=Path, help="Python to seed the venv (must be inside the uenv)")
    ap.add_argument("--force", action="store_true", help="Remove existing venv if present")
    ap.add_argument("--copies", action="store_true", help="Use file copies instead of symlinks")
    args = ap.parse_args()

    mount, name, view = parse_uenv()

    if not name:
        sys.exit("ERROR: Could not detect uenv.")

    if not view:
        sys.exit("ERROR: Could not detect active view.")

    if not mount.is_dir():
        sys.exit(f"ERROR: mount point does not exist: {mount}")

    # Enforce: interpreter must live inside the uenv mount
    py = args.python.resolve()
    if not py.exists():
        sys.exit(f"ERROR: --python not found: {py}")
    if not py_in_uenv(py, mount):
        sys.exit(f"ERROR: Selected Python is not inside the uenv mount.\n  python: {py}\n  mount:  {mount}\n"
                 "Hint: pass --python /user-environment/env/{view}/bin/python")

    # Compute uenv site-packages path
    uenv_sp = discover_uenv_site_packages(mount, view, py)
    if not uenv_sp.is_dir():
        sys.exit(f"ERROR: uenv site-packages not found: {uenv_sp}")
    print(uenv_sp)

    # Prepare venv dir
    if args.force and args.venv.exists():
        shutil.rmtree(args.venv)
    if args.venv.exists() and any(args.venv.iterdir()):
        sys.exit(f"ERROR: venv directory exists and is not empty: {args.venv} (use --force)")
    args.venv.mkdir(parents=True, exist_ok=True)

    # Build environment without PYTHONPATH
    env = {k: v for k, v in os.environ.items() if k != "PYTHONPATH"}

    # Create venv (prefer uv)
    try:
        create_with_uv(args.venv, py, args.copies, env)
        used = "uv"
    except Exception:
        create_with_stdlib(args.venv, py, args.copies, env)
        used = "venv"

    # Compute venv python & its site-packages
    vpy = args.venv / "bin/python"
    vsp = venv_site_packages(vpy)
    print(vsp)

    # Write .pth so venv sees uenvâ€™s site-packages
    pth = vsp / "uenv.pth"
    pth.write_text(str(uenv_sp) + "\n")

    # Done
    act = args.venv / "bin/activate"
    print(f"uenv-venv created with {used}")
    print(f"  venv:                 {args.venv}")
    print(f"  python:               {py}")
    print(f"  uenv mount/name/view: {mount} / {name} / {view}")
    print(f"  uenv site-pkgs:       {uenv_sp}")
    print(f"  venv site-pkgs:       {vsp}")
    print(f"  wrote:                {pth}")
    print()
    print(f"Activate with:          source {act}")
    print("Sanity check:           python -c \"import sys; print(any('site-packages' in p and '/env/' in p for p in sys.path))\"")

if __name__ == "__main__":
    main()
